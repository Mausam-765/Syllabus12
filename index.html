<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      /* Reset some default styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, sans-serif;

       
      }

      body {
        background-color: #f0f2f5;
        color: #333;
      }

      /* Navigation Bar */
      .navbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 50px;
        background-color: #2c3e50;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .navbar .logo {
        font-size: 24px;
        font-weight: bold;
        color: #ecf0f1;
      }

      .navbar .nav-links {
        list-style: none;
        display: flex;
      }

      .navbar .nav-links li {
        margin-left: 30px;
      }

      .navbar .nav-links a {
        text-decoration: none;
        color: #ecf0f1;
        font-size: 18px;
        position: relative;
        transition: color 0.3s;
      }

      .navbar .nav-links a::after {
        content: "";
        position: absolute;
        width: 0%;
        height: 2px;
        background: #e74c3c;
        left: 0;
        bottom: -5px;
        transition: 0.3s;
      }

      .navbar .nav-links a:hover::after {
        width: 100%;
      }

      .navbar .nav-links a.active {
        color: #e74c3c;
      }

      .navbar .nav-links a.active::after {
        width: 100%;
      }

      /* Header */
      .header-section {
        text-align: center;
        padding: 80px 20px;
        background: linear-gradient(to right, #3498db, #9b59b6);
        color: white;
      }

      .header-section h1 {
        font-size: 40px;
        
      }

      .header-section p {
        font-size: 20px;
      }

      /* Content Sections */
      .content-section {
        padding: 60px 50px;
        background-color: #fff;
        margin: 20px auto;
        border-radius: 10px;
        width: 80%;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        transition: transform 0.3s;
      }

      .content-section:hover {
        transform: translateY(-5px);
      }

      .content-section h2 {
        font-size: 28px;
        margin-bottom: 0;
        color: #2c3e50;
      }
       .content-section h3 {
        font-size: 28px;
        margin-bottom: 0;
        color: #2c3e50;
      }

      .content-section ul {
        list-style-type: disc;
        margin-left: 20px;
      }

      .content-section ul li {
        margin-bottom: 10px;
        font-size: 18px;
      }

      /* Footer */
      footer {
        text-align: center;
        padding: 20px;
        background-color: #2c3e50;
        color: #ecf0f1;
        margin-top: 40px;
      }
      .bigspace{
        line-height:1.7;
      }
    </style>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Computer Syllabus</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Navigation Bar -->
    <nav class="navbar">
      <div class="logo">Computer Syllabus</div>
      <ul class="nav-links">
        <li><a href="#Chapter1">Chapter 1</a></li>
        <li><a href="#Chapter4">Chapter 4</a></li>
        <li><a href="#database">Chapter 4</a></li>
        <li><a href="#ai"></a></li>
      </ul>
    </nav>


    <header class="header-section">
      <h1>Welcome to the Computer Syllabus</h1>
      <p>Explore detailed syllabus for various computer subjects</p>
    </header>


    <section id="Chapter1" class="content-section"  >
    <div class="bigspace">
        <h1>Chapter 1: Database Management System(DBMS)</h1>
        <div>
            <h2>Data vs Information</h2>
            <p><strong>Data</strong> consists of raw facts and figures that by themselves do not carry meaning. These can be numbers, text, images, or sounds collected from various sources. Data alone cannot help in decision-making without interpretation. For example, a temperature reading of "30" is data until you know whether it's in Celsius or Fahrenheit, the location, or time.</p>
            <p><strong>Information</strong> is the processed form of data that is meaningful and useful. It results from organizing, structuring, or presenting data in context. For example, "The temperature in New York on June 15th was 30Â°C, which is higher than the average" is information because it adds context, making the data valuable for analysis or decisions.</p>
            <p>Understanding the distinction is crucial for fields like data science, business intelligence, and database management where the goal is to convert raw data into actionable information.</p>
          
            <h2>Features of Information</h2>
            <ul>
              <li><strong>Accuracy:</strong> Information must be precise and error-free. Inaccurate information can lead to poor decisions or business losses.</li>
              <li><strong>Timeliness:</strong> Information must be available when needed. Outdated information might be irrelevant or misleading.</li>
              <li><strong>Relevance:</strong> The information should be applicable to the purpose it serves, ensuring it meets the needs of users or processes.</li>
              <li><strong>Completeness:</strong> All necessary details should be present for the information to be fully understood and actionable.</li>
              <li><strong>Consistency:</strong> Information should be consistent across different sources and over time to build trust and reliability.</li>
              <li><strong>Understandability:</strong> Information should be presented clearly and understandably so that users can interpret it correctly.</li>
              <li><strong>Accessibility:</strong> Authorized users should be able to easily access the information when needed without unnecessary hurdles.</li>
            </ul>
          
            <h2>Database and Its Purpose</h2>
            <p>A <strong>database</strong> is a collection of related data organized systematically to facilitate easy access, management, and updating. Databases enable users to store vast amounts of information securely and retrieve it quickly using query languages like SQL.</p>
            <p>The primary purpose of a database is to support efficient data storage, retrieval, and manipulation, enabling applications to serve user needs effectively. Databases eliminate redundant data storage, provide data integrity, and support concurrent access by multiple users, which is essential in modern multi-user environments such as banking, e-commerce, and social networking.</p>
            <p>For example, in an online store, a database maintains records of products, customers, orders, and payments, allowing seamless operations like searching products, placing orders, and tracking shipments.</p>
          
            <h2>Terminologies in Database</h2>
            <ul>
              <li><strong>Table:</strong> The basic unit of data storage in relational databases. Each table contains rows (records) and columns (fields), representing entities such as employees or products.</li>
              <li><strong>Field:</strong> A column in a table, defining the data type and meaning of the data stored. For example, "Name," "Date of Birth," or "Price."</li>
              <li><strong>Record:</strong> A row in a table representing a single entity instance, such as a specific employee or product entry.</li>
              <li><strong>Tuple:</strong> Synonymous with a record, emphasizing its ordered structure in a table.</li>
              <li><strong>Object:</strong> In object-oriented or object-relational databases, an object is a data entity encapsulating attributes and behaviors, representing real-world entities more naturally.</li>
              <li><strong>Keys:</strong> Fields that uniquely identify records or establish relationships:
                <ul>
                  <li><em>Primary Key:</em> A unique identifier for each record in a table (e.g., employee ID).</li>
                  <li><em>Foreign Key:</em> A field in one table that links to the primary key in another, establishing relational connections.</li>
                </ul>
              </li>
            </ul>
          
            <h2>Data Dictionary</h2>
            <p>The <strong>data dictionary</strong> is an essential metadata repository in a database system that stores definitions, constraints, and structural information about data elements and their relationships. It acts as a blueprint, documenting the design and structure of the database to aid developers, DBAs, and users in understanding and managing the data.</p>
            <p>It typically includes:</p>
            <ul>
              <li>Table names and descriptions</li>
              <li>Field names, data types, and allowed values</li>
              <li>Relationships and constraints between tables</li>
              <li>Access permissions and user roles</li>
            </ul>
            <p>An accurate data dictionary is crucial for maintaining data integrity, consistency, and facilitating changes or upgrades in the database structure over time.</p>
          
            <h2>Database Management System (DBMS)</h2>
            <h3>Introduction</h3>
            <p>A <strong>DBMS</strong> is a sophisticated software system that provides an interface to define, create, query, update, and administer databases. It abstracts the complexity of data storage and management from users, enabling efficient handling of large data volumes and concurrent multi-user access.</p>
            <p>Popular DBMS examples include MySQL, Oracle, Microsoft SQL Server, and PostgreSQL, widely used in enterprise and web applications.</p>
          
            <h3>Objectives</h3>
            <ul>
              <li>Provide a convenient and efficient environment for users to store and retrieve data.</li>
              <li>Ensure data integrity, security, and privacy.</li>
              <li>Enable concurrent multi-user access with transaction management.</li>
              <li>Provide backup, recovery, and fault tolerance mechanisms.</li>
              <li>Maintain data independence by separating physical and logical data structures.</li>
            </ul>
          
            <h3>Advantages</h3>
            <ul>
              <li><strong>Data Integrity:</strong> DBMS enforces rules to maintain accuracy and consistency of data.</li>
              <li><strong>Security:</strong> Access controls restrict unauthorized data access and manipulation.</li>
              <li><strong>Reduced Redundancy:</strong> Data normalization eliminates duplication, saving storage and improving consistency.</li>
              <li><strong>Backup and Recovery:</strong> DBMS automates data backup and recovery, minimizing data loss risks.</li>
              <li><strong>Multi-User Access:</strong> Supports concurrent access while preventing conflicts through locking and transactions.</li>
            </ul>
          
            <h3>Disadvantages</h3>
            <ul>
              <li><strong>Complexity:</strong> Setting up and managing a DBMS requires skilled personnel and planning.</li>
              <li><strong>Cost:</strong> Licensing, hardware, and maintenance can be expensive.</li>
              <li><strong>Performance Overhead:</strong> Additional layers of abstraction may impact speed compared to file-based systems.</li>
              <li><strong>Single Point of Failure:</strong> Centralized DBMS can cause system-wide downtime if not designed with fault tolerance.</li>
            </ul>
          
            <h2>Types of Database Models</h2>
            <ul>
              <li><strong>Hierarchical Model:</strong>
                <p>Organizes data in a tree-like structure with parent-child relationships, where each child record has only one parent. This model is efficient for representing structured data like organizational charts, XML data, or file systems. However, its rigid hierarchy limits flexibility in representing complex relationships.</p>
              </li>
              <li><strong>Network Model:</strong>
                <p>Extends the hierarchical model by allowing multiple parent records, forming a graph structure. This many-to-many relationship model supports more complex real-world scenarios such as supply chains or telecommunications. Though flexible, network models are complex to design and manage.</p>
              </li>
              <li><strong>Relational Model:</strong>
                <p>The most widely used model today, it stores data in tables (relations) with rows and columns. Data relationships are established using keys, and operations are performed using relational algebra and SQL. This model offers simplicity, data independence, and flexibility, making it suitable for most business applications.</p>
              </li>
              <li><strong>Entity-Relationship Model:</strong>
                <p>Primarily used for database design, this conceptual model uses diagrams (ER diagrams) to illustrate entities, attributes, and relationships. It helps in visualizing and planning the database structure before implementation.</p>
              </li>
            </ul>
          
            <h2>Integrity Constraints and Types</h2>
            <p>Integrity constraints enforce rules on data to ensure accuracy, consistency, and reliability in a database.</p>
            <ul>
              <li><strong>Domain Constraint:</strong> Defines the permissible set of values for a column, such as data type restrictions, value ranges, or formats (e.g., a date field must be a valid date).</li>
              <li><strong>Entity Integrity:</strong> Ensures that each tableâs primary key is unique and not null, so every record is uniquely identifiable.</li>
              <li><strong>Referential Integrity:</strong> Maintains valid relationships between tables by ensuring foreign keys correspond to existing primary keys. It prevents orphan records and maintains relational consistency.</li>
              <li><strong>Key Constraints:</strong> Enforce uniqueness and correct usage of primary and foreign keys to maintain data consistency.</li>
            </ul>
          
            <h2>Normalization</h2>
            <h3>Introduction</h3>
            <p>Normalization is a systematic approach of decomposing tables to minimize data redundancy and eliminate undesirable characteristics like update, insert, and delete anomalies. It improves data integrity and efficiency in relational databases by organizing data into multiple related tables.</p>
            <p>Normalization follows several stages called normal forms, each with specific rules:</p>
          
            <h3>Normal Forms</h3>
            <ul>
              <li><strong>First Normal Form (1NF):</strong> Ensures that all table columns contain atomic, indivisible values, and there are no repeating groups or arrays within rows.</li>
              <li><strong>Second Normal Form (2NF):</strong> Achieved when the table is in 1NF and all non-key attributes are fully functionally dependent on the entire primary key, removing partial dependencies.</li>
              <li><strong>Third Normal Form (3NF):</strong> Reached when the table is in 2NF and all attributes are only dependent on the primary key, eliminating transitive dependencies.</li>
            </ul>
          
            <h3>Advantages of Normalization</h3>
            <ul>
              <li>Eliminates redundant data, reducing storage needs.</li>
              <li>Ensures data consistency and accuracy.</li>
              <li>Makes the database easier to maintain and update.</li>
              <li>Improves query performance by structuring data efficiently.</li>
            </ul>
          
            <h3>Disadvantages of Normalization</h3>
            <ul>
              <li>Increased number of tables can make queries more complex and slower due to joins.</li>
              <li>Over-normalization may result in performance bottlenecks.</li>
              <li>Sometimes denormalization is preferred for read-heavy applications to improve speed.</li>
            </ul>
          
            <h2>Centralized and Distributed Database</h2>
            <h3>Introduction</h3>
            <p><strong>Centralized Database</strong> systems store data in a single central location managed by one DBMS instance. All data access, processing, and administration occur on this central server.</p>
            <p><strong>Distributed Database</strong> systems distribute data across multiple physical locations, connected through a network but appear as a single database to users. This approach can enhance performance, fault tolerance, and scalability.</p>
            <img src="dbtype.png" width=500px>
          
            <h3>Advantages</h3>
            <ul>
              <li><strong>Centralized:</strong> Easier management, simplified backup, and strong data integrity due to centralized control.</li>
              <li><strong>Distributed:</strong> Improved reliability (no single point of failure), better performance by localizing data access, and scalability by adding nodes.</li>
            </ul>
          
            <h3>Disadvantages</h3>
            <ul>
              <li><strong>Centralized:</strong> Potential bottlenecks and vulnerability to single points of failure.</li>
              <li><strong>Distributed:</strong> Complex data synchronization, possible consistency issues, and higher maintenance costs.</li>
            </ul>
          
            <h3>Comparison</h3>
            <table boarder="1" cellpadding="5" cellspacing="0">
              <thead>
                <tr>
                  <th>Feature</th>
                  <th>Centralized Database</th>
                  <th>Distributed Database</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Data Location</td>
                  <td>Stored in one place</td>
                  <td>Spread across multiple locations</td>
                </tr>
                <tr>
                  <td>Management Complexity</td>
                  <td>Simple</td>
                  <td>Complex</td>
                </tr>
                <tr>
                  <td>Fault Tolerance</td>
                  <td>Low (single point of failure)</td>
                  <td>High (redundant nodes)</td>
                </tr>
                <tr>
                  <td>Performance</td>
                  <td>Limited by server capability</td>
                  <td>Potentially higher through parallelism</td>
                </tr>
                <tr>
                  <td>Cost</td>
                  <td>Lower initial cost</td>
                  <td>Higher infrastructure and maintenance costs</td>
                </tr>
              </tbody>
            </table>
          
            <h2>Database Security</h2>
            <h3>Introduction</h3>
            <p>Database security involves protecting the database against unauthorized access, misuse, or theft. It is critical because databases often store sensitive information such as personal data, financial records, and proprietary business information.</p>
          
            <h3>Challenges</h3>
            <ul>
              <li>Preventing unauthorized access from hackers or malicious insiders.</li>
              <li>Protecting against SQL injection and other cyber attacks.</li>
              <li>Maintaining privacy and compliance with regulations such as GDPR or HIPAA.</li>
              <li>Ensuring data availability despite threats like denial of service attacks.</li>
            </ul>
          
            <h3>Security Measures</h3>
            <ul>
              <li><strong>Authentication:</strong> Verifying user identities through passwords, biometrics, or tokens.</li>
              <li><strong>Authorization:</strong> Granting appropriate access rights based on user roles.</li>
              <li><strong>Encryption:</strong> Protecting data at rest and in transit using cryptographic techniques.</li>
              <li><strong>Auditing:</strong> Keeping logs of access and modifications for accountability.</li>
              <li><strong>Backup and Recovery:</strong> Regularly backing up data to recover from security breaches or data loss.</li>
            </ul>
          
            <h3>Roles of DBA (Database Administrator)</h3>
            <p>The DBA plays a crucial role in managing database security, performance, and availability. Key responsibilities include:</p>
            <ul>
              <li>Installing and configuring the DBMS software.</li>
              <li>Defining and enforcing security policies.</li>
              <li>Performing backup and recovery operations.</li>
              <li>Monitoring system performance and tuning databases.</li>
              <li>Managing user accounts, roles, and privileges.</li>
              <li>Ensuring data integrity and compliance with regulations.</li>
            </ul>
          
            <h2>Practical Topics: DDL and DML Languages</h2>
            <p><strong>Data Definition Language (DDL)</strong> commands are used to define and modify database structures such as tables, indexes, and schemas. Common DDL commands include <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code>.</p>
            <p><strong>Data Manipulation Language (DML)</strong> commands are used to manipulate data stored within tables. These include <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code>.</p>
          
            <h2>SQL Data Types</h2>
            <p>SQL supports various data types to define the nature and constraints of data stored in table fields:</p>
            <ul>
              <li><strong>CHAR(size):</strong> Fixed-length character string. Useful for storing data with a fixed size, such as country codes.</li>
              <li><strong>VARCHAR(size):</strong> Variable-length character string. Efficient for storing text with varying lengths, like names or emails.</li>
              <li><strong>BINARY(size):</strong> Fixed-length binary data, used to store raw bytes.</li>
              <li><strong>VARBINARY(size):</strong> Variable-length binary data.</li>
              <li><strong>TINYBLOB:</strong> Very small binary large object (up to 255 bytes).</li>
              <li><strong>TINYTEXT:</strong> Very small text data.</li>
              <li><strong>TEXT:</strong> Large text data (up to 65,535 characters).</li>
              <li><strong>LONGTEXT:</strong> Very large text data (up to 4GB).</li>
              <li><strong>ENUM:</strong> A string object that can have one value chosen from a list of predefined values.</li>
              <li><strong>BIT:</strong> Stores bit-field values.</li>
              <li><strong>TINYINT:</strong> Very small integer (usually 1 byte).</li>
              <li><strong>BOOLEAN:</strong> Stores true or false values (often implemented as TINYINT).</li>
              <li><strong>INTEGER:</strong> Standard integer value.</li>
              <li><strong>FLOAT:</strong> Floating-point number with single precision.</li>
              <li><strong>DOUBLE:</strong> Floating-point number with double precision.</li>
              <li><strong>DECIMAL(p,s):</strong> Fixed-point number with precision <em>p</em> and scale <em>s</em>, suitable for financial calculations.</li>
              <li><strong>DATE:</strong> Stores calendar dates (year, month, day).</li>
              <li><strong>DATETIME:</strong> Stores date and time values.</li>
            </ul>
              <h2>SQL JOINs</h2>
        <p>SQL JOINs are used to combine rows from two or more tables based on a related column.</p>
        
        <h3>1. INNER JOIN</h3>
        <p>Returns records that have matching values in both tables.</p>
        <pre><code>
SELECT employees.name, departments.dept_name
FROM employees
INNER JOIN departments
ON employees.dept_id = departments.id;
        </code></pre>

        <h3>2. LEFT JOIN</h3>
        <p>Returns all records from the left table, and the matched records from the right table.</p>
        <pre><code>
SELECT employees.name, departments.dept_name
FROM employees
LEFT JOIN departments
ON employees.dept_id = departments.id;
        </code></pre>

        <h3>3. RIGHT JOIN</h3>
        <p>Returns all records from the right table, and the matched records from the left table.</p>
        <pre><code>
SELECT employees.name, departments.dept_name
FROM employees
RIGHT JOIN departments
ON employees.dept_id = departments.id;
        </code></pre>

        <h3>4. FULL JOIN</h3>
        <p>Returns all records when there is a match in either left or right table.</p>
        <pre><code>
SELECT employees.name, departments.dept_name
FROM employees
FULL OUTER JOIN departments
ON employees.dept_id = departments.id;
        </code></pre>
          </div>
          <h1>DBMS Questions and Answers (2020-2024)</h1>
          <ol>
            <li>
              <strong>What is Database and DBMS? List out the advantages and disadvantages of DBMS.</strong><br>
              A database is an organized collection of data. DBMS (Database Management System) is software that manages databases.
              <br><strong>Advantages:</strong> Reduces data redundancy, ensures data integrity, supports multi-user access, enables backup and recovery.<br>
              <strong>Disadvantages:</strong> Expensive hardware/software, complex to manage, requires skilled personnel.
            </li>
        
            <li>
              <strong>Differentiate between file processing system and DBMS:</strong><br>
              1. File system has data redundancy; DBMS reduces it.<br>
              2. File system is application-dependent; DBMS is independent.<br>
              3. File system has limited security; DBMS has better security.<br>
              4. File system lacks backup/recovery; DBMS supports both.
            </li>
        
            <li>
              <strong>Explain different models of DBMS with advantages and disadvantages:</strong><br>
              - <strong>Hierarchical:</strong> Tree-like structure. Fast access but rigid.<br>
              - <strong>Network:</strong> Many-to-many relations. Flexible but complex.<br>
              - <strong>Relational:</strong> Uses tables. Easy to use and scalable but slower for complex data.<br>
              - <strong>Object-Oriented:</strong> Supports objects. Good for complex apps but less mature.
            </li>
        
            <li>
              <strong>What is a relational database? How is it different?</strong><br>
              A relational database stores data in tables with rows and columns. It's different due to its use of primary/foreign keys and structured query language (SQL).
            </li>
        
            <li>
              <strong>What is data redundancy? How does DBMS help in reducing it?</strong><br>
              Data redundancy is the duplication of data. DBMS reduces it by using normalization and shared access to a central database.
            </li>
        
            <li>
              <strong>Differentiate between centralized and distributed database systems:</strong><br>
              - Centralized: Data stored in one location. Easier to manage but less fault-tolerant.<br>
              - Distributed: Data distributed over multiple locations. More reliable but complex.
            </li>
        
            <li>
              <strong>Who is DBA? Responsibilities?</strong><br>
              DBA (Database Administrator) manages and maintains the database.<br>
              Responsibilities: Installation, configuration, backup, recovery, security, performance tuning.
            </li>
        
            <li>
              <strong>Define normalization. Explain 1NF, 2NF, 3NF:</strong><br>
              Normalization is the process of organizing data to reduce redundancy.<br>
              - <strong>1NF:</strong> No repeating groups. Example: Separate multiple phone numbers into rows.<br>
              - <strong>2NF:</strong> Remove partial dependencies. Every non-key attribute depends on whole primary key.<br>
              - <strong>3NF:</strong> Remove transitive dependencies. Non-key attributes should not depend on other non-key attributes.
            </li>
        
            <li>
              <strong>Explain primary key, foreign key, candidate key:</strong><br>
              - <strong>Primary key:</strong> Unique identifier (e.g., StudentID).<br>
              - <strong>Foreign key:</strong> Refers to primary key in another table.<br>
              - <strong>Candidate key:</strong> All possible keys that can become primary.
            </li>
        
            <li>
              <strong>What is SQL? Explain components and functions:</strong><br>
              SQL (Structured Query Language) is used to interact with databases.<br>
              - <strong>Components:</strong> DDL, DML, DCL, TCL.<br>
              - <strong>Functions:</strong> SELECT, INSERT, UPDATE, DELETE, JOINs, etc.
            </li>
        
            <li>
              <strong>SQL commands:</strong>
              <ol type="a">
                <li><code>CREATE TABLE students (Id INT, Name VARCHAR(50), Class VARCHAR(20), Marks INT);</code><br><img src="s1.png"></li>
                <li><code>INSERT INTO students (Id, Name, Class, Marks)
VALUES 
(1, 'Anita', '10A', 78),
(2, 'Ramesh', '10B', 82),
(3, 'Sita', '10A', 90),
(4, 'John', '10C', 69);</code><br><img src="s2.png"></li>
                <li><code>SELECT * FROM students;</code><br><img src="s3.png"></li>
                <li><code>UPDATE students SET Marks = 85 WHERE Name = 'Anita';</code><br><img src="s4.png"></li>
                <li><code>DELETE FROM students WHERE Id = 3;</code><br><img src="s5.png"></li>
              </ol>
            </li>
        
            <li>
              <strong>Define the following terms:</strong>
              <ol type="a">
                <li><strong>Data Dictionary:</strong> Metadata about database structure.</li>
                <li><strong>Primary Key:</strong> Unique column identifying a record.</li>
                <li><strong>Relationship:</strong> Association between tables using keys.</li>
                <li><strong>DML:</strong> Data Manipulation Language (e.g., SELECT, INSERT).</li>
                <li><strong>SQL:</strong> Language to manage and query databases.</li>
                <li><strong>Data Integrity:</strong> Accuracy and consistency of data.</li>
                <li><strong>DDL:</strong> Data Definition Language (e.g., CREATE, ALTER).</li>
                <li><strong>Data Security:</strong> Protecting data from unauthorized access.</li>
                <li><strong>Database System:</strong> The database + DBMS software + users + applications.</li>
              </ol>
            </li>
          </ol>
              
            <blockquote>


     </div>
    </section>

    <!-- Networking Section -->
    <section id="Chapter4" class="content-section">

 <h1>Chapter 4: Programming In C</h1></blockquote>
        <div class="adswrapper"> 
    

          <h2>1. Working with a Function</h2>
          <h3>a. Define Function</h3>
          <p>A function is a block of code that performs a specific task, can be called multiple times, and can return a value.</p>
      
          <h3>b. Syntax of Functions</h3>
          <pre><code>return_type function_name(parameters) {
          // code to execute
      }</code></pre>
      
          <h3>c. Types of Functions</h3>
          <ul>
              <li><strong>Library Functions</strong> (e.g., <code>printf()</code>, <code>scanf()</code>)</li>
              <li><strong>User-Defined Functions</strong> (custom created by the programmer)</li>
          </ul>
      
          <h3>d. Components of Function</h3>
          <ul>
              <li><strong>Function Prototype:</strong> Declaration before main function</li>
              <li><strong>Function Call:</strong> Invoking the function</li>
              <li><strong>Function Definition:</strong> Body of the function</li>
              <li><strong>Return Type:</strong> Type of value returned by the function</li>
          </ul>
      
          <strong>Categories of function with example:</strong>
          <ol type="i">
            <li><strong>Function with return type but no arguments:</strong>
              <pre><code>#include &lt;stdio.h&gt;
    
    int getValue() {
      int value = 42;
      printf("Inside getValue function...\n");
      return value;
    }
    
    int main() {
      printf("Calling getValue()...\n");
      int result = getValue();
      printf("The value is: %d\n", result);
      return 0;
    }</code></pre><img src="1.png">
            </li>
            <li><strong>Function with return type with arguments:</strong>
              <pre><code>#include &lt;stdio.h&gt;
    
    int multiply(int a, int b) {
      printf("Multiplying %d and %d...\n", a, b);
      int product = a * b;
      return product;
    }
    
    int main() {
      int x = 6, y = 7;
      printf("Calling multiply(%d, %d)...\n", x, y);
      int result = multiply(x, y);
      printf("Product: %d\n", result);
      return 0;
    }</code></pre><img src="2.png">
            </li>
            <li><strong>Function with no return type with no arguments:</strong>
              <pre><code>#include &lt;stdio.h&gt;
    
    void greet() {
      printf("Welcome to C Programming!\n");
      printf("This is a simple greeting message.\n");
    }
    
    int main() {
      printf("Calling greet()...\n");
      greet();
      printf("greet() function executed.\n");
      return 0;
    }</code></pre><img src="3.png">
            </li>
            <li><strong>Function with no return type with arguments:</strong>
              <pre><code>#include &lt;stdio.h&gt;
    
    void displaySum(int x, int y) {
      int sum = x + y;
      printf("Calculating sum of %d and %d...\n", x, y);
      printf("The sum is: %d\n", sum);
    }
    
    int main() {
      int a = 12, b = 8;
      printf("Calling displaySum(%d, %d)...\n", a, b);
      displaySum(a, b);
      return 0;
    }</code></pre><img src="4.png">
            </li>
          </ol>
        </li>
      
      <h2>Storage Classes in C</h2>

      <p>Storage classes in C define the scope (visibility), lifetime (existence), and default initial value of variables. There are four main types of storage classes:</p>
    
      <h4>1. Automatic (<code>auto</code>)</h4>
      <p>This is the default storage class for local variables declared inside a function. These variables are created when the function is called and destroyed when the function exits. They are not accessible outside the function.</p>
    
      <h3>Example:</h3>
      <pre><code>#include &lt;stdio.h&gt;
    
    void showAuto() {
        auto int x = 10;
        printf("Auto variable: %d\n", x);
    }
    
    int main() {
        showAuto();
        return 0;
    }
    </code></pre>
    
      <h4>2. External (<code>extern</code>)</h4>
      <p>The <code>extern</code> storage class is used to declare a global variable or function that is defined in another file or later in the same file. It is useful for accessing global variables across multiple files.</p>
    
      <h3>Example:</h3>
      <pre><code>// File1.c
    #include &lt;stdio.h&gt;
    
    int count = 10; // Global variable
    
    void display() {
        printf("Count = %d\n", count);
    }
    
    // File2.c
    extern int count;
    
    int main() {
        count++;
        display();
        return 0;
    }
    </code></pre>
      <p><em>Note: Requires two separate files to demonstrate fully. For single-file demo:</em></p>
      <pre><code>#include &lt;stdio.h&gt;
    
    int count = 5; // Global variable
    
    void display();
    
    int main() {
        extern int count;
        count++;
        display();
        return 0;
    }
    
    void display() {
        printf("Extern variable count = %d\n", count);
    }
    </code></pre>
    
      <h4>3. Register (<code>register</code>)</h4>
      <p>Variables declared with <code>register</code> suggest to the compiler to store them in the CPU registers instead of RAM for faster access. It is commonly used for frequently accessed variables like loop counters. You cannot access the address of register variables using the <code>&</code> operator.</p>
    
      <h3>Example:</h3>
      <pre><code>#include &lt;stdio.h&gt;
    
    int main() {
        register int i;
        for(i = 0; i &lt; 5; i++) {
            printf("Register variable i = %d\n", i);
        }
        return 0;
    }
    </code></pre>
    
      <h4>4. Static (<code>static</code>)</h4>
      <p>The <code>static</code> storage class retains the value of a variable between function calls. A static variable inside a function keeps its value across invocations. A static global variable or function is limited to the file scope (not visible in other files).</p>
    
      <h3>Example 1: Static variable in a function</h3>
      <pre><code>#include &lt;stdio.h&gt;
    
    void counter() {
        static int count = 0;  // Initialized once
        count++;
        printf("Static count = %d\n", count);
    }
    
    int main() {
        counter();
        counter();
        counter();
        return 0;
    }
    </code></pre>
    
      <h3>Example 2: Static global variable (not accessible in other files)</h3>
      <pre><code>static int globalCount = 0;
    
    void add() {
        globalCount++;
    }
    </code></pre>
      
          <h2>4. Recursive Function</h2>
          <p>A function that calls itself until a base condition is met.</p>
          <pre><code>int factorial(int n) {
          if(n == 0)
              return 1;
          else
              return n * factorial(n - 1);
      }</code></pre>
      
          <h2>5. Passing Array to a Function</h2>
          <pre><code>void printArray(int arr[], int size) {
          for(int i = 0; i &lt; size; i++) {
              printf("%d ", arr[i]);
          }
      }</code></pre>
          <p>Call from <code>main()</code>:</p>
          <pre><code>int main() {
          int numbers[] = {1, 2, 3, 4, 5};
          printArray(numbers, 5);
          return 0;
      }</code></pre>
      <pre><code>#include &lt;stdio.h&gt;

        void doubleElements(int arr[], int size) {
            for(int i = 0; i &lt; size; i++) {
                arr[i] *= 2;
            }
        }
        
        int main() {
            int data[] = {10, 20, 30};
            doubleElements(data, 3);
            for(int i = 0; i &lt; 3; i++) {
                printf("%d ", data[i]);
            }
            return 0;
        }
        </code></pre>
        
          <h3>Passing a 2D Array</h3>
          <pre><code>#include &lt;stdio.h&gt;
        
        void printMatrix(int mat[2][3]) {
            for(int i = 0; i &lt; 2; i++) {
                for(int j = 0; j &lt; 3; j++) {
                    printf("%d ", mat[i][j]);
                }
                printf("\n");
            }
        }
        
        int main() {
            int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}};
            printMatrix(matrix);
            return 0;
        }
        </code></pre><img src="11.png">
        
          <h3>Finding Maximum in Array</h3>
          <pre><code>#include &lt;stdio.h&gt;
        
        int findMax(int arr[], int size) {
            int max = arr[0];
            for(int i = 1; i &lt; size; i++) {
                if(arr[i] &gt; max)
                    max = arr[i];
            }
            return max;
        }
           <section>
         
        <h2>Structure in C</h2>
        <p>A structure is a user-defined data type that allows grouping variables of different types under a single name.</p>

        <h3>Syntax</h3>
        <pre><code>
struct StructureName {
    data_type member1;
    data_type member2;
    ...
};
        </code></pre>
         <h3>Structure Size</h3>
        <p>Size of a structure is the sum of sizes of all its members, including padding added for alignment.</p>

        <h3>Accessing Members</h3>
        <pre><code>
#include &lt;stdio.h&gt;

struct Person {
    char name[50];
    int age;
};

int main() {
    struct Person p1 = {"Neha", 22};
    printf("Name: %s, Age: %d", p1.name, p1.age);
    return 0;
}
        </code></pre>

        <h3>Nested Structure</h3>
        <pre><code>
struct Date {
    int day;
    int month;
    int year;
};

struct Person {
    char name[50];
    struct Date dob;
};

struct Person p1 = {"Neha", {1, 9, 2003}};
        </code></pre>

        <h3>Array of Structures</h3>
        <pre><code>
struct Student {
    char name[50];
    int roll;
};

struct Student class[3] = { {"A", 1}, {"B", 2}, {"C", 3} };
        </code></pre>

        <h3>Passing Structure to Function</h3>
        <pre><code>
#include &lt;stdio.h&gt;

struct Student {
    char name[50];
    int roll;
};

void printStudent(struct Student s) {
    printf("Name: %s, Roll: %d", s.name, s.roll);
}

int main() {
    struct Student s1 = {"Neha", 101};
    printStudent(s1);
    return 0;
}
        </code></pre>
    </section>

    <!-- Union Section -->
    <section>
        <h2>Union in C</h2>
        <p>Union is similar to structure, but all members share the same memory location. Only one member can store a value at a time.</p>

        <h3>Syntax</h3>
        <pre><code>
union UnionName {
    data_type member1;
    data_type member2;
    ...
};
        </code></pre>

        <h3>Comparison: Structure vs Union</h3>
        <ul>
            <li>Structure allocates memory for all members, Union allocates memory equal to the largest member.</li>
            <li>Structure members can store values simultaneously, Union only one at a time.</li>
        </ul>
    </section>

    <!-- Pointers Section -->
    <section>
        <h2>Pointers in C</h2>
        <p>Pointers store the memory addresses of variables. They are used for dynamic memory, function arguments, and arrays.</p>

        <h3>Declaration & Initialization</h3>
        <pre><code>
int x = 10;
int *p = &x;   // Pointer storing address of x
        </code></pre>

        <h3>Pointer and Function</h3>
        <pre><code>
#include &lt;stdio.h&gt;

void increment(int *num) {
    (*num)++;
}

int main() {
    int a = 5;
    increment(&a);
    printf("Value: %d", a);
    return 0;
}
        </code></pre>

        <h3>Call by Reference vs Call by Value</h3>
        <ul>
            <li>Call by value passes a copy of variable.</li>
            <li>Call by reference passes the address, allowing function to modify original variable.</li>
        </ul>

        <h3>Pointer with Arrays</h3>
        <pre><code>
#include &lt;stdio.h&gt;

int main() {
    int arr[5] = {1,2,3,4,5};
    int *p = arr;

    for(int i=0; i&lt;5; i++)
        printf("%d ", *(p+i));
    return 0;
}
        </code></pre>

        <h3>Advantages and Disadvantages</h3>
        <ul>
            <li>Efficient memory usage and fast access</li>
            <li>Enables dynamic memory allocation</li>
            <li>Can be complex and error-prone (dangling pointers, segmentation faults)</li>
        </ul>
    </section>

    <!-- File Handling Section -->
    <section>
        <h2>File Handling in C</h2>
        <p>Files are used to store data permanently. C provides functions for sequential and random access.</p>

        <h3>Concept and Need</h3>
        <ul>
            <li>Data files store information permanently</li>
            <li>Required to save data beyond program execution</li>
        </ul>

        <h3>Sequential and Random Files</h3>
        <ul>
            <li>Sequential: Data is processed in order</li>
            <li>Random: Data can be accessed at any position</li>
        </ul>

        <h3>File Handling Functions</h3>
        <pre><code>
// Open and close
fopen("file.txt", "r/w/a");
fclose(fp);

// Read and Write
getc(fp);   putc(ch, fp);
fscanf(fp, "%s", str);   fprintf(fp, "%s", str);
getw(fp);   putw(num, fp);
fgets(str, n, fp);   fputs(str, fp);
fread(buffer, size, n, fp);   fwrite(buffer, size, n, fp);

// File operations
remove("file.txt");   rename("old.txt","new.txt");
        </code></pre>

        <h3>Random Access Functions</h3>
        <pre><code>
fseek(fp, offset, SEEK_SET);   // Move pointer
ftell(fp);                     // Return current position
rewind(fp);                     // Move pointer to beginning
        </code></pre>

        <h3>File Opening Modes</h3>
        <ul>
            <li>Read: r, r+</li>
            <li>Write: w, w+</li>
            <li>Append: a, a+</li>
        </ul>

        <h3>Steps to Work with Files</h3>
        <ol>
            <li>Define file pointer</li>
            <li>Open file with required mode</li>
            <li>Read, write, or append data</li>
            <li>Close the file</li>
        </ol>

        <h3>Example: Writing and Reading File</h3>
        <pre><code>
#include &lt;stdio.h&gt;

int main() {
    FILE *fp;
    char str[50];

    // Writing
    fp = fopen("data.txt", "w");
    fprintf(fp, "Hello World");
    fclose(fp);

    // Reading
    fp = fopen("data.txt", "r");
    fscanf(fp, "%s", str);
    printf("Data: %s", str);
    fclose(fp);

    return 0;
}
        </code></pre>

        <h3>End of File (EOF)</h3>
        <p>EOF indicates the end of a file while reading.</p>
        <pre><code>
while((ch = getc(fp)) != EOF) {
    putchar(ch);
}
        </code></pre>
    </section>
    <section>
    <h2>Typedef in C</h2>
    <p><strong>Typedef</strong> is a keyword in C used to create a new name (alias) for an existing data type. It improves code readability ,<br> and makes it easier to modify data types later.</p>

    <h3>Syntax</h3>
    <pre><code>
typedef existing_data_type new_name;
    </code></pre>

    <h3>Examples</h3>
    <pre><code>
// Example 1: Simple alias
typedef unsigned int UINT;
UINT age = 25;

// Example 2: Struct alias
typedef struct {
    char name[50];
    int roll;
} Student;

Student s1 = {"Neha", 101};
printf("Name: %s, Roll: %d", s1.name, s1.roll);
    </code></pre>

    <h3>Advantages of Typedef</h3>
    <ul>
        <li>Makes code more readable and maintainable</li>
        <li>Easy to modify underlying data type</li>
        <li>Useful for defining complex data types like structs and pointers</li>
    </ul>
</section>
</div>   


    </section>

    
    <footer>
      <p>&copy; 2025 Computer Syllabus | Designed by Mausam Thapaliya</p>
    </footer>

    <script>
      // Smooth scrolling for navigation links
      const links = document.querySelectorAll(".nav-links a");
      links.forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          document.querySelector(link.getAttribute("href")).scrollIntoView({
            behavior: "smooth",
          });

          // Highlight active link
          links.forEach((l) => l.classList.remove("active"));
          link.classList.add("active");
        });
      });
    </script>
  </body>
</html>
